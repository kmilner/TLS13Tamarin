dnl Include a DC extension
define(<!CertificateExtensions!>, <!<'ce', DelegatedCredential>!>)dnl
dnl

rule recv_server_auth_DC:
let
    prev_psk_ke_mode = 'na'
    set_state()

    S = $S
    C = $C

    certificate_request_context = '0'
    certificate = pk(~ltkS)

    credential = pk(~ltkE)
    cred_sig_input_msgs = credential_signature_input(certificate, server)
    dc = DelegatedCredential
    messages = <messages, Certificate>
    sig_messages = signature_input(server)

    messages = <messages, CertificateVerify>

    exp_verify_data = compute_finished(server)

    messages = <messages, Finished>

    cats = application_traffic_secret_0(client)
    sats = application_traffic_secret_0(server)
    app_keys = keygen(sats, app_key_label())
    ems = exporter_master_secret()

    // auth_status = <cas, sas>
    auth_status = <'0', 'auth'>
in
    [ State(C2d, tid, C, S, PrevClientState)[no_precomp],
      !Pk(S, pk(~ltkS)),
      !Pk(E, pk(~ltkE)),
      In(senc{Certificate, CertificateVerify, Finished}hs_keys)
    ]
  --[ C2d(tid),
      Instance(tid, C, 'client'),
      Eq(psk_ke_mode, 'na'),
      Eq(verify(signature, sig_messages, pk(~ltkE)), true),
      Eq(verify(cred_signature, cred_sig_input_msgs, pk(~ltkS)), true),
      Eq(verify_data, exp_verify_data),
      running_client(Mode, psk_ke_mode),
      commit_client(Identity, <S, auth_status>),
      commit_client(HS, hs),
      commit_client(Transcript, messages),
      commit_client(Nonces, nc, ns),
      commit_client(DC, S, E)
    ]->
    [ State(C3, tid, C, S, ClientState),
      RecvStream(tid, C, S, auth_status, app_keys)
    ]

rule server_auth_DC:
let
    set_state()

    C = $C
    S = $S
    E = $E 

    certificate_request_context = '0'
    certificate = pk(~ltkS)
    credential = pk(~ltkE)

    messages = <messages, Certificate>
    signature = compute_signature(~ltkE, server)

    messages = <messages, CertificateVerify>

    verify_data = compute_finished(server)

    messages = <messages, Finished>
    ems = exporter_master_secret()
    cats = application_traffic_secret_0(client)
    sats = application_traffic_secret_0(server)
    app_keys = keygen(sats, app_key_label())

    // auth_status = <sas, cas>
    auth_status = <'auth', '0'>
in
    [ State(S2d, tid, S, C, PrevServerState)[no_precomp]
    , !Ltk(E, ~ltkE)
    , !Pk(S, pk(~ltkS))
    , !DC(E, S, DelegatedCredential)
    ]
  --[ S2d(tid),
      Instance(tid, S, 'server'),
      Eq(psk_ke_mode, 'na'),
      UseLtk(~ltkE, signature),
      running_server(Transcript, messages)
    ]->
    [ State(S3, tid, S, C, ServerState),
      SendStream(tid, S, C, auth_status, app_keys),
      Out(senc{Certificate, CertificateVerify, Finished}hs_keys)
    ]
